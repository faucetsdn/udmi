#!/bin/bash -e

ROOT=$(dirname $0)/..
cd $ROOT
DROOT=.

function usage {
    echo Error: $*
    echo Usage: $0 { prep, build, shell, run, push, deploy, update, status, logs, stop } [repo] [--no-check]
    echo Project: $GCP_PROJECT
    echo Try starting with: $0 build
    exit 1
}

cmd=$1
shift || usage missing command

GCP_PROJECT=$(gcloud config get project)
REPOSITORY=gcr.io/$GCP_PROJECT

mkdir -p tmp

IMAGE=udmis

if [[ $1 == "--no-check" ]]; then
    NOCHECK=1
    shift
fi

if [[ $1 == "--selfie" ]]; then
    IMAGE=selfie
    shift
fi

if [[ -n $1 ]]; then
    REPOSITORY=$1
    shift
fi

echo Using GCP project $GCP_PROJECT

if [[ -z $NOCHECK ]]; then
    CONTEXT=`kubectl config current-context`
    CONTEXT_ARGS=(${CONTEXT//_/ })
    KPROJECT=${CONTEXT_ARGS[1]}
    if [[ $KPROJECT != $GCP_PROJECT ]]; then
        echo Kubernetes context $CONTEXT does not match gcloud project $GCP_PROJECT
        false
    fi
fi

LIBFILE=build/libs/udmis-1.0-SNAPSHOT-all.jar

current_user=$USER@$HOSTNAME
revparse=`git rev-parse HEAD`
revparse=g${revparse:0:9}
version=`git describe --abbrev=0 || echo $revparse`
srcver=`git describe --dirty || echo $revparse`
funchash=`git log -n 1 --oneline -- src/ | awk '{print $1}'`
funccount=`git diff --name-only -- src/ | wc -l`
if [[ $funccount != 0 ]]; then
    funcdirty=-dirty
fi
funcver=`git describe $funchash || echo $revparse`$funcdirty

RUNARGS="--rm -ti -v $PWD/var:/udmi -v $HOME/.config:/root/.config --tmpfs /tmp --env GCP_PROJECT=$GCP_PROJECT"
TEMPLATES=$(cd etc; ls k8s_*.yaml)

if [[ $cmd == prep || $cmd == build ]]; then
    rm -rf var tmp && mkdir -p var
    bin/build
    build_time=`date --utc -Imin -r $LIBFILE`
    cp etc/prod_pod.json var/
    cat <<EOF > var/deployed_version.json
{
  "udmi_version": "$version",
  "udmi_source": "$srcver",
  "udmi_functions": "$funcver",
  "built_at": "$build_time",
  "built_by": "$current_user"
}
EOF
    more var/deployed_version.json | cat
    echo Next try: $0 build
fi

if [[ $cmd == build ]]; then
    echo Building Dockerfile.$IMAGE
    docker build -f Dockerfile.$IMAGE -t $IMAGE $DROOT
    echo Next try: $0 push
elif [[ $cmd == run ]]; then
    docker run $RUNARGS $IMAGE
elif [[ $cmd == shell ]]; then
    docker run $RUNARGS $IMAGE bash
elif [[ $cmd == push ]]; then
    IMAGENAME=$REPOSITORY/$IMAGE
    docker tag $IMAGE $IMAGENAME
    docker push $IMAGENAME
    hash=$(docker images --digests $IMAGENAME | fgrep latest | awk '{print $3}')
    ihash=$IMAGENAME@$hash
    for file in $TEMPLATES; do
        sed < etc/$file > tmp/$file \
            -e "s^@IMAGE-$IMAGE@^$ihash^" \
            -e "s^@GCP_PROJECT@^$GCP_PROJECT^" \
            -e "s^@CLEARBLADE_PROJECT@^$CLEARBLADE_PROJECT^"
        echo Updated tmp/$file with image $ihash
    done
    echo Next try: $0 deploy
elif [[ $cmd == deploy ]]; then
    kubectl apply -f tmp/k8s_pod.yaml
    kubectl apply -f tmp/k8s_broker.yaml
    echo Next try: $0 status
elif [[ $cmd == status ]]; then
    kubectl describe pods udmis-test-pod
    echo Next try: $0 logs
elif [[ $cmd == logs ]]; then
    kubectl logs udmis-test-pod
elif [[ $cmd == stop ]]; then
    kubectl delete pod/udmis-test-pod
elif [[ $cmd == update ]]; then
    kubectl apply -f tmp/k8s_deployment.yaml
elif [[ $cmd == remove ]]; then
    kubectl delete deployment/udmis-pods
else
    echo Unknown command $cmd
    false
fi
