#!/bin/bash -e

# Force consistent sort order
export LC_ALL=C

ROOT_DIR=$(dirname $0)/..
cd $ROOT_DIR

debug_opts=-v
seq_opts=
clean_cache=
pubber_opts=
suffix=
out_check=y

if [[ $1 == 'clean' ]]; then
    shift
    clean_cache=y
fi

if [[ $1 == 'alpha' ]]; then
    shift
    seq_opts=-x
fi

if [[ $1 == 'nostate' ]]; then
    shift
    pubber_opts+=" noState"
    suffix=_nostate
fi

if [[ $1 == 'nocheck' ]]; then
    shift
    out_check=
fi

if [[ $1 == 'full' ]]; then
    shift
    debug_opts=
fi

if [[ $# -lt 1 ]]; then
    echo Usage: $0 [clean] [alpha] [nostate] [full] PROJECT_ID [tests...]
    false
fi

project_id=$1
shift
targets=$*

[[ -n $GITHUB_RUN_NUMBER ]] && echo "Workflow run number $GITHUB_RUN_NUMBER" || true
echo "export TARGET_PROJECT=$project_id"
echo "export UDMI_REGISTRY_SUFFIX=$UDMI_REGISTRY_SUFFIX"
echo "export UDMI_ALT_REGISTRY=$UDMI_ALT_REGISTRY"
echo "export MATRIX_SHARD_COUNT=$MATRIX_SHARD_COUNT"
echo "export MATRIX_SHARD_INDEX=$MATRIX_SHARD_INDEX"

site_path=sites/udmi_site_model
device_id=AHU-1
output_file=$site_path/out/sequencer_$device_id.json
device_out_base=$site_path/out/devices/$device_id
test_out_base=$device_out_base/tests

if [[ -n $clean_cache ]]; then
    echo Cleaning out/ $test_out_base/
    rm -rf out/ $test_out_base/
fi

mkdir -p $test_out_base out/

serial_no=sequencer-$RANDOM
echo Using pubber with serial $serial_no

PUBBER_OUT=out/pubber.out

pids=`ps ax | fgrep pubber | fgrep java | awk '{print $1}'`
if [[ -n $pids ]]; then
    echo Killing pubber pids $pids
    kill $pids
fi

bin/clone_model # Clone, and check that version is correct.

bin/reset_config $site_path $project_id $device_id

# Clean out the persistant data store to ensure a clean state each time.
rm -rf $site_path/out/devices/${device_id}/persistent_data.json

pubber/bin/build

echo Writing pubber output to $PUBBER_OUT
echo bin/pubber $site_path $project_id $device_id $serial_no $pubber_opts
bin/pubber $site_path $project_id $device_id $serial_no $pubber_opts > $PUBBER_OUT 2>&1 &

WAITING=10
for i in `seq 1 $WAITING`; do
    if fgrep "Connection complete" $PUBBER_OUT; then
        break
    fi
    echo Waiting for pubber startup $((WAITING - i))...
    sleep 2
done

if [[ $i -eq $WAITING ]]; then
    echo pubber startup failed:
    cat $PUBBER_OUT
    false
fi

# Augment the device metadata to that tests know what to expect...
bin/augment_metadata $site_path $device_id $pubber_opts

# Run in debug mode for fail-fast when things go wrong!
echo bin/sequencer $debug_opts $seq_opts $site_path $project_id $device_id $serial_no $targets
bin/sequencer $debug_opts $seq_opts $site_path $project_id $device_id $serial_no $targets
echo Completed execution of sequencer test run.

echo Checking reported cloud version info
jq .cloud_version.udmi_ref $output_file

pids=`ps ax | fgrep pubber | fgrep java | awk '{print $1}'`
if [[ -n $pids ]]; then
    echo Killing pubber pids $pids
    kill $pids
else
    echo No pubber pids found, likely due to premature termination: failing test run.
    false
fi

echo Combining partial-run output files...
ls -l out/schema.out* out/sequencer.log* || true

cat out/schema.out >> out/schema.out.combined
cat out/sequencer.log >> out/sequencer.log.combined

if [[ -n $out_check ]]; then
    if [[ -n $clean_cache ]]; then
        echo Cleaning sequencer result cache...
        rm -rf validator/sequences
    fi

    bin/test_sequcheck $suffix
else
    if [[ -n $clean_cache ]]; then
        echo Cleaning sequencer out archive...
        rm -rf $site_path/out-seq
    fi

    echo Archiving $site_path/out to $site_path/out-seq
    rsync -ah $site_path/out/ $site_path/out-seq/
    rm -rf $site_path/out
fi

echo Done with $suffix test_sequencer run.
